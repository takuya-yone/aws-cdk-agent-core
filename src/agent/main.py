"""Simple Strands Agent for AgentCore Runtime.

Uses BedrockAgentCoreApp for simplified deployment
"""

import json
from collections.abc import AsyncIterator
from datetime import datetime
from zoneinfo import ZoneInfo

import uvicorn
from bedrock_agentcore.memory.integrations.strands.config import AgentCoreMemoryConfig
from bedrock_agentcore.memory.integrations.strands.session_manager import (
    AgentCoreMemorySessionManager,
)
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from models import (
    AgentCoreInvokeLogModel,
    EventTypeEnum,
    InvocationRequestModel,
    InvocationResponseModel,
    UsageAttribute,
)
from nanoid import generate
from settings import memory_settings, model_settings
from sse_starlette.sse import EventSourceResponse
from strands import Agent, tool
from strands.agent.agent_result import AgentResult
from strands.types.event_loop import Usage
from sub_agents import (
    aws_access_agent,
    aws_rss_agent,
    estate_agent,
    react_agent,
    search_agent,
    weather_agent,
)
from utils import logger

# strands.agent.agent_result.AgentResult
# Initialize the AgentCore app
# app = BedrockAgentCoreApp()
app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

model = model_settings.get_model()


@tool
def call_weather_agent(city: str) -> str:
    """Call agent to get weather information using the weather_agent.
    Args:
        city: The name of the city
    Returns:
        A string describing the weather
    """

    result = weather_agent(f"Get the weather for {city} and current time.")
    logger.info(
        f"Weather agent called for city: {city}",
        extra={"city": city, "tool": "call_weather_agent"},
    )
    return result


@tool
def call_search_agent(query: str) -> dict:
    """Call agent to perform web search using the search_agent.
    Args:
        query: The search query string
    Returns:
        The search results as a dictionary
    """

    result = search_agent(f"Search the web for {query}")
    logger.info(
        f"Search agent called for query: {query}",
        extra={"query": query, "tool": "call_search_agent"},
    )
    return result


@tool
def call_aws_rss_agent(keyword: str) -> list:
    """Call agent to fetch AWS RSS feed items using the aws_rss_agent.
    Args:
        keyword: The keyword to search for in the RSS feed
    Returns:
        A list of RSS feed items matching the keyword
    """

    result = aws_rss_agent(f"Fetch RSS feed items for {keyword}")
    logger.info(
        f"AWS RSS agent called for keyword: {keyword}",
        extra={"keyword": keyword, "tool": "call_aws_rss_agent"},
    )
    return result


@tool
def call_react_agent(topic: str) -> str:
    """Call agent to fetch front-end best practices using the react_agent.
    Args:
        topic: The specific topic or area of interest
    Returns:
        A string describing best practices
    """

    result = react_agent(f"Provide best practices for {topic}")
    logger.info(
        f"React agent called for topic: {topic}",
        extra={"topic": topic, "tool": "call_react_agent"},
    )
    return result


@tool
def call_estate_agent(query: str) -> dict:
    """Call agent to perform estate knowledge base retrieval using the estate_agent.
    Args:
        query: The query string related to estate information
    Returns:
        The retrieval results as a dictionary
    """

    result = estate_agent(f"Retrieve estate information for {query}")
    logger.info(
        f"Estate agent called for query: {query}",
        extra={"query": query, "tool": "call_estate_agent"},
    )
    return result


@tool
def call_aws_access_agent(topic: str) -> str:
    """Call agent to fetch AWS access guidance using the aws_access_agent.
    Args:
        topic: The specific topic or area of interest related to AWS access
    Returns:
        A string describing AWS access guidance
    """

    result = aws_access_agent(f"Provide guidance on AWS access for {topic}")
    logger.info(
        f"AWS Access agent called for topic: {topic}",
        extra={"topic": topic, "tool": "call_aws_access_agent"},
    )
    return result


def save_invocation_log(
    invocation_id: str,
    payload: InvocationRequestModel,
    usage: Usage,
    output: str,
):
    """
    Save the invocation log to the database

    :param invocation_id: Unique identifier for the invocation
    :type invocation_id: str
    :param payload: The request payload containing the user prompt and optional actor/session IDs
    :type payload: InvocationRequestModel
    :param usage: The usage information containing token usage details
    :type usage: Usage
    :param output: The output generated by the agent
    :type output: str
    """
    log_entry = AgentCoreInvokeLogModel(
        InvocationId=invocation_id,
        ActorId=payload.actor_id,
        Timestamp=datetime.now(ZoneInfo("Asia/Tokyo")).isoformat(),
        SessionId=payload.session_id,
        Input=payload.prompt,
        Output=output,
        Usage=UsageAttribute.from_usage(usage),
    )
    log_entry.save()


async def entrypoint(invocation_id: str, payload: InvocationRequestModel):
    """
    Entry point for handling agent invocations.

    :param invocation_id: Unique identifier for the invocation
    :type invocation_id: str
    :param payload: The request payload containing the user prompt and optional actor/session IDs
    :type payload: InvocationRequestModel
    """

    agentcore_memory_config = AgentCoreMemoryConfig(
        memory_id=memory_settings.memory_id,
        session_id=payload.session_id,
        actor_id=payload.actor_id,
    )
    agentcore_session_manager = AgentCoreMemorySessionManager(
        agentcore_memory_config=agentcore_memory_config,
    )

    # Create agent with the sub-agents as tools
    main_agent = Agent(
        name="main_agent",
        model=model,
        session_manager=agentcore_session_manager,
        tools=[
            call_weather_agent,
            call_search_agent,
            call_aws_rss_agent,
            call_react_agent,
            call_aws_access_agent,
            call_estate_agent,
        ],
        system_prompt="""
            You are a kind AI assistant.
            Please answer user questions politely.
            If real estate information is needed, use call_estate_agent to retrieve it.
            If front-end/React/Next.js best practices are needed, use call_react_agent to provide guidance.
            If weather information is needed, please use the call_weather_agent.
            If information is unknown, use call_search_agent to search.
            If AWS RSS feed items are needed, use call_aws_rss_agent to fetch them.
            If AWS access guidance is needed, use call_aws_access_agent to provide guidance.
            Answer in the language used by the user.
        """,
    )

    # Stream responses back to the caller
    stream_messages: AsyncIterator[dict] = main_agent.stream_async(payload.prompt)
    async for msg in stream_messages:
        event_key = list(msg.keys())[0]

        # Depending on the event type, construct the appropriate response
        if event_key == "event":
            event = msg.get("event")
            event_type = list(event.keys())[0]
            event_type_enum = EventTypeEnum[event_type]
            response = InvocationResponseModel(
                event=event_type_enum, data=json.dumps(event, ensure_ascii=False)
            )
            yield response.model_dump(mode="json")

        # Save the invocation log when the final result is received
        if event_key == "result":
            result: AgentResult = msg["result"]

            total_usage = result.metrics.accumulated_usage
            output_message = result.message.get("content")[0].get("text")

            save_invocation_log(invocation_id, payload, total_usage, output_message)


# Define API endpoints
@app.get("/ping")
async def ping():
    """Health check endpoint."""
    return {"status": "healthy"}


@app.post("/invocations", response_model=InvocationResponseModel)
async def invocations(payload: InvocationRequestModel) -> InvocationResponseModel:
    invocation_id = generate(alphabet="0123456789abcdefghijklmnopqrst", size=10)
    logger.info("Invocation started...", extra={"invocation_id": invocation_id})

    if not payload.actor_id:
        payload.actor_id = invocation_id
    if not payload.session_id:
        payload.session_id = "default-session"

    return EventSourceResponse(
        entrypoint(invocation_id, payload),
        media_type="text/event-stream",
    )


if __name__ == "__main__":
    # AgentCore Runtime listens on port 8080 for incoming requests
    uvicorn.run(app, host="0.0.0.0", port=8080, log_config=None)
