"""Simple Strands Agent for AgentCore Runtime.

Uses BedrockAgentCoreApp for simplified deployment
"""

import json
from datetime import datetime
from enum import Enum
from zoneinfo import ZoneInfo

import uvicorn
from aws_lambda_powertools import Logger
from bedrock_agentcore.memory.integrations.strands.config import AgentCoreMemoryConfig
from bedrock_agentcore.memory.integrations.strands.session_manager import (
    AgentCoreMemorySessionManager,
)
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from models import AgentCoreInvokeLogModel
from nanoid import generate
from pydantic import BaseModel
from settings import memory_settings, model_settings
from sse_starlette.sse import EventSourceResponse
from strands import Agent, tool
from sub_agents import (
    aws_access_agent,
    aws_rss_agent,
    react_agent,
    search_agent,
    weather_agent,
)

# Initialize the AgentCore app
# app = BedrockAgentCoreApp()
app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

model = model_settings.get_model()
logger = Logger()


@tool
def call_weather_agent(city: str) -> str:
    """Call agent to get weather information using the weather_agent.
    Args:
        city: The name of the city
    Returns:
        A string describing the weather
    """

    result = weather_agent(f"Get the weather for {city} and current time.")
    logger.info(
        f"Weather agent called for city: {city}",
        extra={"city": city, "tool": "call_weather_agent"},
    )
    return result


@tool
def call_search_agent(query: str) -> dict:
    """Call agent to perform web search using the search_agent.
    Args:
        query: The search query string
    Returns:
        The search results as a dictionary
    """

    result = search_agent(f"Search the web for {query}")
    logger.info(
        f"Search agent called for query: {query}",
        extra={"query": query, "tool": "call_search_agent"},
    )
    return result


@tool
def call_aws_rss_agent(keyword: str) -> list:
    """Call agent to fetch AWS RSS feed items using the aws_rss_agent.
    Args:
        keyword: The keyword to search for in the RSS feed
    Returns:
        A list of RSS feed items matching the keyword
    """

    result = aws_rss_agent(f"Fetch RSS feed items for {keyword}")
    logger.info(
        f"AWS RSS agent called for keyword: {keyword}",
        extra={"keyword": keyword, "tool": "call_aws_rss_agent"},
    )
    return result


@tool
def call_react_agent(topic: str) -> str:
    """Call agent to fetch front-end best practices using the react_agent.
    Args:
        topic: The specific topic or area of interest
    Returns:
        A string describing best practices
    """

    result = react_agent(f"Provide best practices for {topic}")
    logger.info(
        f"React agent called for topic: {topic}",
        extra={"topic": topic, "tool": "call_react_agent"},
    )
    return result


@tool
def call_aws_access_agent(topic: str) -> str:
    """Call agent to fetch AWS access guidance using the aws_access_agent.
    Args:
        topic: The specific topic or area of interest related to AWS access
    Returns:
        A string describing AWS access guidance
    """

    result = aws_access_agent(f"Provide guidance on AWS access for {topic}")
    logger.info(
        f"AWS Access agent called for topic: {topic}",
        extra={"topic": topic, "tool": "call_aws_access_agent"},
    )
    return result


class EventTypeEnum(Enum):
    messageStart = "messageStart"  # noqa: N815
    contentBlockStart = "contentBlockStart"  # noqa: N815
    contentBlockDelta = "contentBlockDelta"  # noqa: N815
    contentBlockStop = "contentBlockStop"  # noqa: N815
    messageStop = "messageStop"  # noqa: N815
    metadata = "metadata"


class InvocationRequestModel(BaseModel):
    prompt: str
    actor_id: str | None = None
    session_id: str | None = None


class InvocationResponseModel(BaseModel):
    event: EventTypeEnum
    data: str


def save_invocation_log(
    invocation_id: str, payload: InvocationRequestModel, output: str
):
    """
    Save the invocation log to the database

    :param invocation_id: Unique identifier for the invocation
    :type invocation_id: str
    :param payload: The request payload containing the user prompt and optional actor/session IDs
    :type payload: InvocationRequestModel
    :param output: The output generated by the agent
    :type output: str
    """
    log_entry = AgentCoreInvokeLogModel(
        InvocationId=invocation_id,
        ActorId=payload.actor_id,
        Timestamp=datetime.now(ZoneInfo("Asia/Tokyo")).isoformat(),
        SessionId=payload.session_id,
        Input=payload.prompt,
        Output=output,
    )
    log_entry.save()


async def entrypoint(invocation_id: str, payload: InvocationRequestModel):
    """
    Entry point for handling agent invocations.

    :param invocation_id: Unique identifier for the invocation
    :type invocation_id: str
    :param payload: The request payload containing the user prompt and optional actor/session IDs
    :type payload: InvocationRequestModel
    """

    agentcore_memory_config = AgentCoreMemoryConfig(
        memory_id=memory_settings.memory_id,
        session_id=payload.session_id,
        actor_id=payload.actor_id,
    )
    agentcore_session_manager = AgentCoreMemorySessionManager(
        agentcore_memory_config=agentcore_memory_config,
    )

    # Create agent with the sub-agents as tools
    main_agent = Agent(
        name="main_agent",
        model=model,
        session_manager=agentcore_session_manager,
        tools=[
            call_weather_agent,
            call_search_agent,
            call_aws_rss_agent,
            call_react_agent,
            call_aws_access_agent,
        ],
        system_prompt="""
            You are a kind AI assistant.
            Please answer user questions politely.
            If front-end/React/Next.js best practices are needed, use call_react_agent to provide guidance.
            If weather information is needed, please use the call_weather_agent.
            If information is unknown, use call_search_agent to search.
            If AWS RSS feed items are needed, use call_aws_rss_agent to fetch them.
            If AWS access guidance is needed, use call_aws_access_agent to provide guidance.
            Answer in the language used by the user.
        """,
    )

    # Stream responses back to the caller
    response_msg_list = []
    stream_messages = main_agent.stream_async(payload.prompt)
    async for msg in stream_messages:
        if "event" in msg:
            event = msg.get("event", {})
            event_type = list(event.keys())[0]
            event_type_enum = EventTypeEnum[event_type]
            response = InvocationResponseModel(
                event=event_type_enum, data=json.dumps(event, ensure_ascii=False)
            )
            yield response.model_dump(mode="json")

            # Update the log with the latest output
            if EventTypeEnum.contentBlockDelta.value in msg["event"]:
                response_msg_list.append(
                    msg["event"][EventTypeEnum.contentBlockDelta.value]["delta"].get(
                        "text", ""
                    )
                )

    # Save the invocation log after processing
    save_invocation_log(invocation_id, payload, "".join(response_msg_list))

    # result = await main_agent.invoke_async(message)
    # yield result


# Define API endpoints
@app.get("/ping")
async def ping():
    """Health check endpoint."""
    return {"status": "healthy"}


@app.post("/invocations", response_model=EventSourceResponse)
async def invocations(payload: InvocationRequestModel) -> EventSourceResponse:
    invocation_id = generate(alphabet="0123456789abcdefghijklmnopqrst", size=10)
    logger.info("Invocation started...", extra={"invocation_id": invocation_id})

    if not payload.actor_id:
        payload.actor_id = invocation_id
    if not payload.session_id:
        payload.session_id = "default-session"

    return EventSourceResponse(
        entrypoint(invocation_id, payload),
        media_type="text/event-stream",
    )


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8080, log_level="debug")
